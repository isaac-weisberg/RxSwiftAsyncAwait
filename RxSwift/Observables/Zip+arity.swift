// This file is autogenerated. Take a look at `Preprocessor` target in RxSwift project 
//
//  Zip+arity.swift
//  RxSwift
//
//  Created by Krunoslav Zaher on 5/23/15.
//  Copyright Â© 2015 Krunoslav Zaher. All rights reserved.
//



// 2

private enum Elem2<E1: Sendable, E2: Sendable>: Sendable {
    case e1(E1)
    case e2(E2)
}

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.

    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)

    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
    */
    public static func zip<O1: ObservableType, O2: ObservableType>
        (
           _ source1: O1,
           _ source2: O2,
            resultSelector: @escaping (
               O1.Element,
               O2.Element
            ) throws -> Element
        )
        -> Observable<Element> {
        
        typealias Elem = Elem2<O1.Element, O2.Element>

        return zip([
           source1.thinMap(Elem.e1),
           source2.thinMap(Elem.e2),
        ], resultSelector: { elems in
            if
                case .e1(let e1) = elems[0],
                case .e2(let e2) = elems[1]
            {
                try resultSelector(e1, e2)
            } else {
                fatalError()
            }
        })
    }
}

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.

    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)

    - returns: An observable sequence containing the result of combining elements of the sources.
    */
    public static func zip<O1: ObservableType, O2: ObservableType>
        (_ source1: O1, _ source2: O2)
    -> Observable<(O1.Element, O2.Element)> where Element == (O1.Element, O2.Element) {
        zip(
           source1,
           source2,
            resultSelector: { ($0, $1) }
        )
    }
}



// 3

private enum Elem3<E1: Sendable, E2: Sendable, E3: Sendable>: Sendable {
    case e1(E1)
    case e2(E2)
    case e3(E3)
}

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.

    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)

    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
    */
    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType>
        (
           _ source1: O1,
           _ source2: O2,
           _ source3: O3,
            resultSelector: @escaping (
               O1.Element,
               O2.Element,
               O3.Element
            ) throws -> Element
        )
        -> Observable<Element> {
        
        typealias Elem = Elem3<O1.Element, O2.Element, O3.Element>

        return zip([
           source1.thinMap(Elem.e1),
           source2.thinMap(Elem.e2),
           source3.thinMap(Elem.e3),
        ], resultSelector: { elems in
            if
                case .e1(let e1) = elems[0],
                case .e2(let e2) = elems[1],
                case .e3(let e3) = elems[2]
            {
                try resultSelector(e1, e2, e3)
            } else {
                fatalError()
            }
        })
    }
}

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.

    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)

    - returns: An observable sequence containing the result of combining elements of the sources.
    */
    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3)
    -> Observable<(O1.Element, O2.Element, O3.Element)> where Element == (O1.Element, O2.Element, O3.Element) {
        zip(
           source1,
           source2,
           source3,
            resultSelector: { ($0, $1, $2) }
        )
    }
}



// 4

private enum Elem4<E1: Sendable, E2: Sendable, E3: Sendable, E4: Sendable>: Sendable {
    case e1(E1)
    case e2(E2)
    case e3(E3)
    case e4(E4)
}

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.

    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)

    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
    */
    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType>
        (
           _ source1: O1,
           _ source2: O2,
           _ source3: O3,
           _ source4: O4,
            resultSelector: @escaping (
               O1.Element,
               O2.Element,
               O3.Element,
               O4.Element
            ) throws -> Element
        )
        -> Observable<Element> {
        
        typealias Elem = Elem4<O1.Element, O2.Element, O3.Element, O4.Element>

        return zip([
           source1.thinMap(Elem.e1),
           source2.thinMap(Elem.e2),
           source3.thinMap(Elem.e3),
           source4.thinMap(Elem.e4),
        ], resultSelector: { elems in
            if
                case .e1(let e1) = elems[0],
                case .e2(let e2) = elems[1],
                case .e3(let e3) = elems[2],
                case .e4(let e4) = elems[3]
            {
                try resultSelector(e1, e2, e3, e4)
            } else {
                fatalError()
            }
        })
    }
}

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.

    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)

    - returns: An observable sequence containing the result of combining elements of the sources.
    */
    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4)
    -> Observable<(O1.Element, O2.Element, O3.Element, O4.Element)> where Element == (O1.Element, O2.Element, O3.Element, O4.Element) {
        zip(
           source1,
           source2,
           source3,
           source4,
            resultSelector: { ($0, $1, $2, $3) }
        )
    }
}



// 5

private enum Elem5<E1: Sendable, E2: Sendable, E3: Sendable, E4: Sendable, E5: Sendable>: Sendable {
    case e1(E1)
    case e2(E2)
    case e3(E3)
    case e4(E4)
    case e5(E5)
}

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.

    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)

    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
    */
    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType>
        (
           _ source1: O1,
           _ source2: O2,
           _ source3: O3,
           _ source4: O4,
           _ source5: O5,
            resultSelector: @escaping (
               O1.Element,
               O2.Element,
               O3.Element,
               O4.Element,
               O5.Element
            ) throws -> Element
        )
        -> Observable<Element> {
        
        typealias Elem = Elem5<O1.Element, O2.Element, O3.Element, O4.Element, O5.Element>

        return zip([
           source1.thinMap(Elem.e1),
           source2.thinMap(Elem.e2),
           source3.thinMap(Elem.e3),
           source4.thinMap(Elem.e4),
           source5.thinMap(Elem.e5),
        ], resultSelector: { elems in
            if
                case .e1(let e1) = elems[0],
                case .e2(let e2) = elems[1],
                case .e3(let e3) = elems[2],
                case .e4(let e4) = elems[3],
                case .e5(let e5) = elems[4]
            {
                try resultSelector(e1, e2, e3, e4, e5)
            } else {
                fatalError()
            }
        })
    }
}

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.

    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)

    - returns: An observable sequence containing the result of combining elements of the sources.
    */
    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5)
    -> Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element)> where Element == (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element) {
        zip(
           source1,
           source2,
           source3,
           source4,
           source5,
            resultSelector: { ($0, $1, $2, $3, $4) }
        )
    }
}



// 6

private enum Elem6<E1: Sendable, E2: Sendable, E3: Sendable, E4: Sendable, E5: Sendable, E6: Sendable>: Sendable {
    case e1(E1)
    case e2(E2)
    case e3(E3)
    case e4(E4)
    case e5(E5)
    case e6(E6)
}

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.

    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)

    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
    */
    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType>
        (
           _ source1: O1,
           _ source2: O2,
           _ source3: O3,
           _ source4: O4,
           _ source5: O5,
           _ source6: O6,
            resultSelector: @escaping (
               O1.Element,
               O2.Element,
               O3.Element,
               O4.Element,
               O5.Element,
               O6.Element
            ) throws -> Element
        )
        -> Observable<Element> {
        
        typealias Elem = Elem6<O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element>

        return zip([
           source1.thinMap(Elem.e1),
           source2.thinMap(Elem.e2),
           source3.thinMap(Elem.e3),
           source4.thinMap(Elem.e4),
           source5.thinMap(Elem.e5),
           source6.thinMap(Elem.e6),
        ], resultSelector: { elems in
            if
                case .e1(let e1) = elems[0],
                case .e2(let e2) = elems[1],
                case .e3(let e3) = elems[2],
                case .e4(let e4) = elems[3],
                case .e5(let e5) = elems[4],
                case .e6(let e6) = elems[5]
            {
                try resultSelector(e1, e2, e3, e4, e5, e6)
            } else {
                fatalError()
            }
        })
    }
}

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.

    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)

    - returns: An observable sequence containing the result of combining elements of the sources.
    */
    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6)
    -> Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element)> where Element == (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element) {
        zip(
           source1,
           source2,
           source3,
           source4,
           source5,
           source6,
            resultSelector: { ($0, $1, $2, $3, $4, $5) }
        )
    }
}



// 7

private enum Elem7<E1: Sendable, E2: Sendable, E3: Sendable, E4: Sendable, E5: Sendable, E6: Sendable, E7: Sendable>: Sendable {
    case e1(E1)
    case e2(E2)
    case e3(E3)
    case e4(E4)
    case e5(E5)
    case e6(E6)
    case e7(E7)
}

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.

    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)

    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
    */
    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType>
        (
           _ source1: O1,
           _ source2: O2,
           _ source3: O3,
           _ source4: O4,
           _ source5: O5,
           _ source6: O6,
           _ source7: O7,
            resultSelector: @escaping (
               O1.Element,
               O2.Element,
               O3.Element,
               O4.Element,
               O5.Element,
               O6.Element,
               O7.Element
            ) throws -> Element
        )
        -> Observable<Element> {
        
        typealias Elem = Elem7<O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element>

        return zip([
           source1.thinMap(Elem.e1),
           source2.thinMap(Elem.e2),
           source3.thinMap(Elem.e3),
           source4.thinMap(Elem.e4),
           source5.thinMap(Elem.e5),
           source6.thinMap(Elem.e6),
           source7.thinMap(Elem.e7),
        ], resultSelector: { elems in
            if
                case .e1(let e1) = elems[0],
                case .e2(let e2) = elems[1],
                case .e3(let e3) = elems[2],
                case .e4(let e4) = elems[3],
                case .e5(let e5) = elems[4],
                case .e6(let e6) = elems[5],
                case .e7(let e7) = elems[6]
            {
                try resultSelector(e1, e2, e3, e4, e5, e6, e7)
            } else {
                fatalError()
            }
        })
    }
}

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.

    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)

    - returns: An observable sequence containing the result of combining elements of the sources.
    */
    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7)
    -> Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element)> where Element == (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element) {
        zip(
           source1,
           source2,
           source3,
           source4,
           source5,
           source6,
           source7,
            resultSelector: { ($0, $1, $2, $3, $4, $5, $6) }
        )
    }
}



// 8

private enum Elem8<E1: Sendable, E2: Sendable, E3: Sendable, E4: Sendable, E5: Sendable, E6: Sendable, E7: Sendable, E8: Sendable>: Sendable {
    case e1(E1)
    case e2(E2)
    case e3(E3)
    case e4(E4)
    case e5(E5)
    case e6(E6)
    case e7(E7)
    case e8(E8)
}

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.

    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)

    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
    */
    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType, O8: ObservableType>
        (
           _ source1: O1,
           _ source2: O2,
           _ source3: O3,
           _ source4: O4,
           _ source5: O5,
           _ source6: O6,
           _ source7: O7,
           _ source8: O8,
            resultSelector: @escaping (
               O1.Element,
               O2.Element,
               O3.Element,
               O4.Element,
               O5.Element,
               O6.Element,
               O7.Element,
               O8.Element
            ) throws -> Element
        )
        -> Observable<Element> {
        
        typealias Elem = Elem8<O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element>

        return zip([
           source1.thinMap(Elem.e1),
           source2.thinMap(Elem.e2),
           source3.thinMap(Elem.e3),
           source4.thinMap(Elem.e4),
           source5.thinMap(Elem.e5),
           source6.thinMap(Elem.e6),
           source7.thinMap(Elem.e7),
           source8.thinMap(Elem.e8),
        ], resultSelector: { elems in
            if
                case .e1(let e1) = elems[0],
                case .e2(let e2) = elems[1],
                case .e3(let e3) = elems[2],
                case .e4(let e4) = elems[3],
                case .e5(let e5) = elems[4],
                case .e6(let e6) = elems[5],
                case .e7(let e7) = elems[6],
                case .e8(let e8) = elems[7]
            {
                try resultSelector(e1, e2, e3, e4, e5, e6, e7, e8)
            } else {
                fatalError()
            }
        })
    }
}

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.

    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)

    - returns: An observable sequence containing the result of combining elements of the sources.
    */
    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType, O8: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8)
    -> Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element)> where Element == (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element) {
        zip(
           source1,
           source2,
           source3,
           source4,
           source5,
           source6,
           source7,
           source8,
            resultSelector: { ($0, $1, $2, $3, $4, $5, $6, $7) }
        )
    }
}


