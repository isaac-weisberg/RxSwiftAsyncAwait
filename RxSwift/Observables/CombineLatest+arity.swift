// This file is autogenerated. Take a look at `Preprocessor` target in RxSwift project 
//
//  CombineLatest+arity.swift
//  RxSwift
//
//  Created by Krunoslav Zaher on 4/22/15.
//  Copyright Â© 2015 Krunoslav Zaher. All rights reserved.
//



// 2

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.

    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)

    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
    */
    public static func combineLatest<O1: ObservableType, O2: ObservableType>
        (_ source1: O1, _ source2: O2, resultSelector: @Sendable @escaping (O1.Element, O2.Element) throws -> Element)
            -> Observable<Element> {
        return CombineLatest2(
            source1: source1, source2: source2,
            resultSelector: resultSelector
        )
    }
}

extension ObservableType where Element == Any {
    /**
    Merges the specified observable sequences into one observable sequence of tuples whenever any of the observable sequences produces an element.

    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)

    - returns: An observable sequence containing the result of combining elements of the sources.
    */
    public static func combineLatest<O1: ObservableType, O2: ObservableType>
        (_ source1: O1, _ source2: O2)
            -> Observable<(O1.Element, O2.Element)> {
        return CombineLatest2(
            source1: source1, source2: source2,
            resultSelector: { ($0, $1) }
        )
    }
}

final class CombineLatest2<O1: ObservableType, O2: ObservableType, Result: Sendable> : Observable<Result> {
    typealias E1 = O1.Element
    typealias E2 = O2.Element
    typealias ResultSelector = @Sendable (E1, E2) throws -> Result

    enum ParameterElement: Sendable {
         case e1(E1)
         case e2(E2)
    }

    let source1: O1
    let source2: O2

    let resultSelector: ResultSelector

    init(source1: O1, source2: O2, resultSelector: @escaping ResultSelector) {
        self.source1 = source1
        self.source2 = source2

        self.resultSelector = resultSelector
        super.init()
    }

    override func subscribe<Observer: ObserverType>(_ c: C, _ observer: Observer) async -> AsynchronousDisposable where Observer.Element == Result {
        let sink = CombineLatestCollectionTypeSink(
            parentSources: [
                source1.map { e1 in ParameterElement.e1(e1) },
                source2.map { e2 in ParameterElement.e2(e2) }
            ], resultSelector: { @Sendable [resultSelector] coll in
                if
                    case .e1(let e1) = coll[0],
                    case .e2(let e2) = coll[1]
                {
                    let result = try resultSelector(
                        e1,
                        e2
                    )
                    return result
                }

                fatalError()
            },
            observer: observer
        )
        await sink.run(c.call())
        return sink
    }
}



// 3

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.

    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)

    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
    */
    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @Sendable @escaping (O1.Element, O2.Element, O3.Element) throws -> Element)
            -> Observable<Element> {
        return CombineLatest3(
            source1: source1, source2: source2, source3: source3,
            resultSelector: resultSelector
        )
    }
}

extension ObservableType where Element == Any {
    /**
    Merges the specified observable sequences into one observable sequence of tuples whenever any of the observable sequences produces an element.

    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)

    - returns: An observable sequence containing the result of combining elements of the sources.
    */
    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3)
            -> Observable<(O1.Element, O2.Element, O3.Element)> {
        return CombineLatest3(
            source1: source1, source2: source2, source3: source3,
            resultSelector: { ($0, $1, $2) }
        )
    }
}

final class CombineLatest3<O1: ObservableType, O2: ObservableType, O3: ObservableType, Result: Sendable> : Observable<Result> {
    typealias E1 = O1.Element
    typealias E2 = O2.Element
    typealias E3 = O3.Element
    typealias ResultSelector = @Sendable (E1, E2, E3) throws -> Result

    enum ParameterElement: Sendable {
         case e1(E1)
         case e2(E2)
         case e3(E3)
    }

    let source1: O1
    let source2: O2
    let source3: O3

    let resultSelector: ResultSelector

    init(source1: O1, source2: O2, source3: O3, resultSelector: @escaping ResultSelector) {
        self.source1 = source1
        self.source2 = source2
        self.source3 = source3

        self.resultSelector = resultSelector
        super.init()
    }

    override func subscribe<Observer: ObserverType>(_ c: C, _ observer: Observer) async -> AsynchronousDisposable where Observer.Element == Result {
        let sink = CombineLatestCollectionTypeSink(
            parentSources: [
                source1.map { e1 in ParameterElement.e1(e1) },
                source2.map { e2 in ParameterElement.e2(e2) },
                source3.map { e3 in ParameterElement.e3(e3) }
            ], resultSelector: { @Sendable [resultSelector] coll in
                if
                    case .e1(let e1) = coll[0],
                    case .e2(let e2) = coll[1],
                    case .e3(let e3) = coll[2]
                {
                    let result = try resultSelector(
                        e1,
                        e2,
                        e3
                    )
                    return result
                }

                fatalError()
            },
            observer: observer
        )
        await sink.run(c.call())
        return sink
    }
}



// 4

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.

    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)

    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
    */
    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @Sendable @escaping (O1.Element, O2.Element, O3.Element, O4.Element) throws -> Element)
            -> Observable<Element> {
        return CombineLatest4(
            source1: source1, source2: source2, source3: source3, source4: source4,
            resultSelector: resultSelector
        )
    }
}

extension ObservableType where Element == Any {
    /**
    Merges the specified observable sequences into one observable sequence of tuples whenever any of the observable sequences produces an element.

    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)

    - returns: An observable sequence containing the result of combining elements of the sources.
    */
    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4)
            -> Observable<(O1.Element, O2.Element, O3.Element, O4.Element)> {
        return CombineLatest4(
            source1: source1, source2: source2, source3: source3, source4: source4,
            resultSelector: { ($0, $1, $2, $3) }
        )
    }
}

final class CombineLatest4<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, Result: Sendable> : Observable<Result> {
    typealias E1 = O1.Element
    typealias E2 = O2.Element
    typealias E3 = O3.Element
    typealias E4 = O4.Element
    typealias ResultSelector = @Sendable (E1, E2, E3, E4) throws -> Result

    enum ParameterElement: Sendable {
         case e1(E1)
         case e2(E2)
         case e3(E3)
         case e4(E4)
    }

    let source1: O1
    let source2: O2
    let source3: O3
    let source4: O4

    let resultSelector: ResultSelector

    init(source1: O1, source2: O2, source3: O3, source4: O4, resultSelector: @escaping ResultSelector) {
        self.source1 = source1
        self.source2 = source2
        self.source3 = source3
        self.source4 = source4

        self.resultSelector = resultSelector
        super.init()
    }

    override func subscribe<Observer: ObserverType>(_ c: C, _ observer: Observer) async -> AsynchronousDisposable where Observer.Element == Result {
        let sink = CombineLatestCollectionTypeSink(
            parentSources: [
                source1.map { e1 in ParameterElement.e1(e1) },
                source2.map { e2 in ParameterElement.e2(e2) },
                source3.map { e3 in ParameterElement.e3(e3) },
                source4.map { e4 in ParameterElement.e4(e4) }
            ], resultSelector: { @Sendable [resultSelector] coll in
                if
                    case .e1(let e1) = coll[0],
                    case .e2(let e2) = coll[1],
                    case .e3(let e3) = coll[2],
                    case .e4(let e4) = coll[3]
                {
                    let result = try resultSelector(
                        e1,
                        e2,
                        e3,
                        e4
                    )
                    return result
                }

                fatalError()
            },
            observer: observer
        )
        await sink.run(c.call())
        return sink
    }
}



// 5

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.

    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)

    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
    */
    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @Sendable @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element) throws -> Element)
            -> Observable<Element> {
        return CombineLatest5(
            source1: source1, source2: source2, source3: source3, source4: source4, source5: source5,
            resultSelector: resultSelector
        )
    }
}

extension ObservableType where Element == Any {
    /**
    Merges the specified observable sequences into one observable sequence of tuples whenever any of the observable sequences produces an element.

    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)

    - returns: An observable sequence containing the result of combining elements of the sources.
    */
    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5)
            -> Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element)> {
        return CombineLatest5(
            source1: source1, source2: source2, source3: source3, source4: source4, source5: source5,
            resultSelector: { ($0, $1, $2, $3, $4) }
        )
    }
}

final class CombineLatest5<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, Result: Sendable> : Observable<Result> {
    typealias E1 = O1.Element
    typealias E2 = O2.Element
    typealias E3 = O3.Element
    typealias E4 = O4.Element
    typealias E5 = O5.Element
    typealias ResultSelector = @Sendable (E1, E2, E3, E4, E5) throws -> Result

    enum ParameterElement: Sendable {
         case e1(E1)
         case e2(E2)
         case e3(E3)
         case e4(E4)
         case e5(E5)
    }

    let source1: O1
    let source2: O2
    let source3: O3
    let source4: O4
    let source5: O5

    let resultSelector: ResultSelector

    init(source1: O1, source2: O2, source3: O3, source4: O4, source5: O5, resultSelector: @escaping ResultSelector) {
        self.source1 = source1
        self.source2 = source2
        self.source3 = source3
        self.source4 = source4
        self.source5 = source5

        self.resultSelector = resultSelector
        super.init()
    }

    override func subscribe<Observer: ObserverType>(_ c: C, _ observer: Observer) async -> AsynchronousDisposable where Observer.Element == Result {
        let sink = CombineLatestCollectionTypeSink(
            parentSources: [
                source1.map { e1 in ParameterElement.e1(e1) },
                source2.map { e2 in ParameterElement.e2(e2) },
                source3.map { e3 in ParameterElement.e3(e3) },
                source4.map { e4 in ParameterElement.e4(e4) },
                source5.map { e5 in ParameterElement.e5(e5) }
            ], resultSelector: { @Sendable [resultSelector] coll in
                if
                    case .e1(let e1) = coll[0],
                    case .e2(let e2) = coll[1],
                    case .e3(let e3) = coll[2],
                    case .e4(let e4) = coll[3],
                    case .e5(let e5) = coll[4]
                {
                    let result = try resultSelector(
                        e1,
                        e2,
                        e3,
                        e4,
                        e5
                    )
                    return result
                }

                fatalError()
            },
            observer: observer
        )
        await sink.run(c.call())
        return sink
    }
}



// 6

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.

    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)

    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
    */
    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @Sendable @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element) throws -> Element)
            -> Observable<Element> {
        return CombineLatest6(
            source1: source1, source2: source2, source3: source3, source4: source4, source5: source5, source6: source6,
            resultSelector: resultSelector
        )
    }
}

extension ObservableType where Element == Any {
    /**
    Merges the specified observable sequences into one observable sequence of tuples whenever any of the observable sequences produces an element.

    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)

    - returns: An observable sequence containing the result of combining elements of the sources.
    */
    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6)
            -> Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element)> {
        return CombineLatest6(
            source1: source1, source2: source2, source3: source3, source4: source4, source5: source5, source6: source6,
            resultSelector: { ($0, $1, $2, $3, $4, $5) }
        )
    }
}

final class CombineLatest6<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, Result: Sendable> : Observable<Result> {
    typealias E1 = O1.Element
    typealias E2 = O2.Element
    typealias E3 = O3.Element
    typealias E4 = O4.Element
    typealias E5 = O5.Element
    typealias E6 = O6.Element
    typealias ResultSelector = @Sendable (E1, E2, E3, E4, E5, E6) throws -> Result

    enum ParameterElement: Sendable {
         case e1(E1)
         case e2(E2)
         case e3(E3)
         case e4(E4)
         case e5(E5)
         case e6(E6)
    }

    let source1: O1
    let source2: O2
    let source3: O3
    let source4: O4
    let source5: O5
    let source6: O6

    let resultSelector: ResultSelector

    init(source1: O1, source2: O2, source3: O3, source4: O4, source5: O5, source6: O6, resultSelector: @escaping ResultSelector) {
        self.source1 = source1
        self.source2 = source2
        self.source3 = source3
        self.source4 = source4
        self.source5 = source5
        self.source6 = source6

        self.resultSelector = resultSelector
        super.init()
    }

    override func subscribe<Observer: ObserverType>(_ c: C, _ observer: Observer) async -> AsynchronousDisposable where Observer.Element == Result {
        let sink = CombineLatestCollectionTypeSink(
            parentSources: [
                source1.map { e1 in ParameterElement.e1(e1) },
                source2.map { e2 in ParameterElement.e2(e2) },
                source3.map { e3 in ParameterElement.e3(e3) },
                source4.map { e4 in ParameterElement.e4(e4) },
                source5.map { e5 in ParameterElement.e5(e5) },
                source6.map { e6 in ParameterElement.e6(e6) }
            ], resultSelector: { @Sendable [resultSelector] coll in
                if
                    case .e1(let e1) = coll[0],
                    case .e2(let e2) = coll[1],
                    case .e3(let e3) = coll[2],
                    case .e4(let e4) = coll[3],
                    case .e5(let e5) = coll[4],
                    case .e6(let e6) = coll[5]
                {
                    let result = try resultSelector(
                        e1,
                        e2,
                        e3,
                        e4,
                        e5,
                        e6
                    )
                    return result
                }

                fatalError()
            },
            observer: observer
        )
        await sink.run(c.call())
        return sink
    }
}



// 7

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.

    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)

    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
    */
    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @Sendable @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element) throws -> Element)
            -> Observable<Element> {
        return CombineLatest7(
            source1: source1, source2: source2, source3: source3, source4: source4, source5: source5, source6: source6, source7: source7,
            resultSelector: resultSelector
        )
    }
}

extension ObservableType where Element == Any {
    /**
    Merges the specified observable sequences into one observable sequence of tuples whenever any of the observable sequences produces an element.

    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)

    - returns: An observable sequence containing the result of combining elements of the sources.
    */
    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7)
            -> Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element)> {
        return CombineLatest7(
            source1: source1, source2: source2, source3: source3, source4: source4, source5: source5, source6: source6, source7: source7,
            resultSelector: { ($0, $1, $2, $3, $4, $5, $6) }
        )
    }
}

final class CombineLatest7<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType, Result: Sendable> : Observable<Result> {
    typealias E1 = O1.Element
    typealias E2 = O2.Element
    typealias E3 = O3.Element
    typealias E4 = O4.Element
    typealias E5 = O5.Element
    typealias E6 = O6.Element
    typealias E7 = O7.Element
    typealias ResultSelector = @Sendable (E1, E2, E3, E4, E5, E6, E7) throws -> Result

    enum ParameterElement: Sendable {
         case e1(E1)
         case e2(E2)
         case e3(E3)
         case e4(E4)
         case e5(E5)
         case e6(E6)
         case e7(E7)
    }

    let source1: O1
    let source2: O2
    let source3: O3
    let source4: O4
    let source5: O5
    let source6: O6
    let source7: O7

    let resultSelector: ResultSelector

    init(source1: O1, source2: O2, source3: O3, source4: O4, source5: O5, source6: O6, source7: O7, resultSelector: @escaping ResultSelector) {
        self.source1 = source1
        self.source2 = source2
        self.source3 = source3
        self.source4 = source4
        self.source5 = source5
        self.source6 = source6
        self.source7 = source7

        self.resultSelector = resultSelector
        super.init()
    }

    override func subscribe<Observer: ObserverType>(_ c: C, _ observer: Observer) async -> AsynchronousDisposable where Observer.Element == Result {
        let sink = CombineLatestCollectionTypeSink(
            parentSources: [
                source1.map { e1 in ParameterElement.e1(e1) },
                source2.map { e2 in ParameterElement.e2(e2) },
                source3.map { e3 in ParameterElement.e3(e3) },
                source4.map { e4 in ParameterElement.e4(e4) },
                source5.map { e5 in ParameterElement.e5(e5) },
                source6.map { e6 in ParameterElement.e6(e6) },
                source7.map { e7 in ParameterElement.e7(e7) }
            ], resultSelector: { @Sendable [resultSelector] coll in
                if
                    case .e1(let e1) = coll[0],
                    case .e2(let e2) = coll[1],
                    case .e3(let e3) = coll[2],
                    case .e4(let e4) = coll[3],
                    case .e5(let e5) = coll[4],
                    case .e6(let e6) = coll[5],
                    case .e7(let e7) = coll[6]
                {
                    let result = try resultSelector(
                        e1,
                        e2,
                        e3,
                        e4,
                        e5,
                        e6,
                        e7
                    )
                    return result
                }

                fatalError()
            },
            observer: observer
        )
        await sink.run(c.call())
        return sink
    }
}



// 8

extension ObservableType {
    /**
    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.

    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)

    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
    */
    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType, O8: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @Sendable @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element) throws -> Element)
            -> Observable<Element> {
        return CombineLatest8(
            source1: source1, source2: source2, source3: source3, source4: source4, source5: source5, source6: source6, source7: source7, source8: source8,
            resultSelector: resultSelector
        )
    }
}

extension ObservableType where Element == Any {
    /**
    Merges the specified observable sequences into one observable sequence of tuples whenever any of the observable sequences produces an element.

    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)

    - returns: An observable sequence containing the result of combining elements of the sources.
    */
    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType, O8: ObservableType>
        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8)
            -> Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element)> {
        return CombineLatest8(
            source1: source1, source2: source2, source3: source3, source4: source4, source5: source5, source6: source6, source7: source7, source8: source8,
            resultSelector: { ($0, $1, $2, $3, $4, $5, $6, $7) }
        )
    }
}

final class CombineLatest8<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType, O8: ObservableType, Result: Sendable> : Observable<Result> {
    typealias E1 = O1.Element
    typealias E2 = O2.Element
    typealias E3 = O3.Element
    typealias E4 = O4.Element
    typealias E5 = O5.Element
    typealias E6 = O6.Element
    typealias E7 = O7.Element
    typealias E8 = O8.Element
    typealias ResultSelector = @Sendable (E1, E2, E3, E4, E5, E6, E7, E8) throws -> Result

    enum ParameterElement: Sendable {
         case e1(E1)
         case e2(E2)
         case e3(E3)
         case e4(E4)
         case e5(E5)
         case e6(E6)
         case e7(E7)
         case e8(E8)
    }

    let source1: O1
    let source2: O2
    let source3: O3
    let source4: O4
    let source5: O5
    let source6: O6
    let source7: O7
    let source8: O8

    let resultSelector: ResultSelector

    init(source1: O1, source2: O2, source3: O3, source4: O4, source5: O5, source6: O6, source7: O7, source8: O8, resultSelector: @escaping ResultSelector) {
        self.source1 = source1
        self.source2 = source2
        self.source3 = source3
        self.source4 = source4
        self.source5 = source5
        self.source6 = source6
        self.source7 = source7
        self.source8 = source8

        self.resultSelector = resultSelector
        super.init()
    }

    override func subscribe<Observer: ObserverType>(_ c: C, _ observer: Observer) async -> AsynchronousDisposable where Observer.Element == Result {
        let sink = CombineLatestCollectionTypeSink(
            parentSources: [
                source1.map { e1 in ParameterElement.e1(e1) },
                source2.map { e2 in ParameterElement.e2(e2) },
                source3.map { e3 in ParameterElement.e3(e3) },
                source4.map { e4 in ParameterElement.e4(e4) },
                source5.map { e5 in ParameterElement.e5(e5) },
                source6.map { e6 in ParameterElement.e6(e6) },
                source7.map { e7 in ParameterElement.e7(e7) },
                source8.map { e8 in ParameterElement.e8(e8) }
            ], resultSelector: { @Sendable [resultSelector] coll in
                if
                    case .e1(let e1) = coll[0],
                    case .e2(let e2) = coll[1],
                    case .e3(let e3) = coll[2],
                    case .e4(let e4) = coll[3],
                    case .e5(let e5) = coll[4],
                    case .e6(let e6) = coll[5],
                    case .e7(let e7) = coll[6],
                    case .e8(let e8) = coll[7]
                {
                    let result = try resultSelector(
                        e1,
                        e2,
                        e3,
                        e4,
                        e5,
                        e6,
                        e7,
                        e8
                    )
                    return result
                }

                fatalError()
            },
            observer: observer
        )
        await sink.run(c.call())
        return sink
    }
}


